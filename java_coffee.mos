(!*******************************************************
  * Assignment 2                                        *
  * ======================                              *
  *                                                     *
  * file java_coffee.mos                                *
  * ````````````````````                                *
  * Find the optimal amount of kgs of coffee to buy and *
  * sell each month during Q1.                          *
  *                                                     *
  * Authors: Robert Creagh, Max Buckley                 *
  * Student Numbers: 15200115, 15203431                 *
  *                                                     *
  * print status procedure copied from                  *
  * potter_goal_preempt.mos by P.Carroll.               *
  *******************************************************!)

model java_coffee_problem
 uses "mmxprs"                   ! Gain access to the Xpress-Optimizer solver

  ! Need to declare and initalize N_MONTHS and N_CONSTRAINTS first so as to be 
  ! able to initalize
  ! variable length arrays below.
  declarations
    N_MONTHS: integer
    N_CONSTRAINTS: integer
  end-declarations
  initializations from 'java_coffee.dat'
    N_MONTHS
    N_CONSTRAINTS
  end-initializations

   ! Main declarations section
  declarations
    indices = 1..N_MONTHS ! Indices for indexing our months.
    no_of_constraints = 1..N_CONSTRAINTS ! Labels for numbering constraints.
    CONSTRAINTS: array(no_of_constraints) of linctr
    CONSTRAINT_NAMES: array(no_of_constraints) of string
    PURCHASE_VOLUME, SELLING_VOLUME: array(indices) of mpvar
    INITIAL_STOCK: real
    INITIAL_CASH_BALANCE: real
    MONTH_NAMES: array(indices) of string
    SELLING_PRICES: array(indices) of real
    PURCHASE_PRICES: array(indices) of real
    CASH_BALANCE: array(indices) of mpvar ! Cash at end of month
    STOCK_LEVEL: array(indices) of mpvar ! Stock at end of month
    WAREHOUSE_SIZE_LIMIT: real
    FINAL_STOCK_TARGET: real
    feasibleU: array(no_of_constraints) of real !array to hold the upper value of feasibility range of the constraints
    feasibleL: array(no_of_constraints) of real !array to hold the lower feasibility range values
  end-declarations

  initializations from 'java_coffee.dat'
    MONTH_NAMES
    SELLING_PRICES
    PURCHASE_PRICES
    INITIAL_STOCK
    INITIAL_CASH_BALANCE
    WAREHOUSE_SIZE_LIMIT
    FINAL_STOCK_TARGET
    CONSTRAINT_NAMES
  end-initializations


  ! Procedure to check problem status
  ! Procedure copied from potter_goal_preempt.mos by P. Carroll
  procedure print_status
    declarations
    status: string
    end-declarations
    case getprobstat of
    XPRS_OPT: status:="LP Optimum found"
    XPRS_UNF: status:="Unfinished"
    XPRS_INF: status:="Infeasible"
    XPRS_UNB: status:="Unbounded"
    XPRS_OTH: status:="Failed"
    else status:="???"
    end-case
    writeln("Problem status: ", status)
  end-procedure

  ! Variable definitions

  ! Define stock level calculations
  STOCK_LEVEL(1) = INITIAL_STOCK + PURCHASE_VOLUME(1) - SELLING_VOLUME(1)

  forall (i in 2..N_MONTHS) do
    STOCK_LEVEL(i) = STOCK_LEVEL(i - 1) + PURCHASE_VOLUME(i) - SELLING_VOLUME(i)
  end-do

  ! Define cash balance calculations
  CASH_BALANCE(1) = (INITIAL_CASH_BALANCE + SELLING_VOLUME(1) *
                     SELLING_PRICES(1) - PURCHASE_VOLUME(1) * PURCHASE_PRICES(1))

  forall (i in 2..N_MONTHS) do
    CASH_BALANCE(i) = (CASH_BALANCE(i - 1) + SELLING_VOLUME(i) *
                       SELLING_PRICES(i) - PURCHASE_VOLUME(i) * PURCHASE_PRICES(i))
  end-do

  ! Objective function
  profit := (sum(i in indices) SELLING_PRICES(i) * SELLING_VOLUME(i) -
       sum(i in indices) PURCHASE_PRICES(i) * PURCHASE_VOLUME(i))

  ! Constraints

  ! Set final month stock target.
  CONSTRAINTS(1):= SELLING_VOLUME(1) <= INITIAL_STOCK
  CONSTRAINTS(2):= STOCK_LEVEL(N_MONTHS) >= FINAL_STOCK_TARGET

  forall(i in indices) CONSTRAINTS(2 + i):= STOCK_LEVEL(i) <= WAREHOUSE_SIZE_LIMIT

  forall (i in 2..N_MONTHS) do ! Start from 2 as already set for month 1.
    CONSTRAINTS(1 + N_MONTHS + i):= SELLING_VOLUME(i) <= STOCK_LEVEL(i - 1)
  end-do

  maximize(profit)

  print_status ! Pretty print status of solution.
  writeln("LP Solution:") ! Solution printing
  writeln("    Profit (Euros): ", getobjval)
  writeln("    Stock remaining in warehouse: ", getsol(STOCK_LEVEL(N_MONTHS)))
  writeln("    Closing cash balance: ", 20000 + getobjval)

  forall(i in indices) do
    writeln("Month: ", MONTH_NAMES(i))
    writeln("    Purchase Volume: ", getsol(PURCHASE_VOLUME(i)))
    writeln("    Sales Volume: ", getsol(SELLING_VOLUME(i)))
  end-do

  ! Sensitivity analysis inspired by sensitivity_pottery_example.mos model
  ! covered in class.
  forall ( j in no_of_constraints) do
        balance(j) := getsol(CONSTRAINTS(j)) !balancing slack or surplus
    writeln("Slack/surplus evaluation of ",CONSTRAINT_NAMES(j)," is: ",balance(j) )
        feasibleU(j) := getrange(XPRS_UPACT, CONSTRAINTS(j)) !I've over written feasible(j)
        writeln("RHS; Upper feasible limit of ", CONSTRAINT_NAMES(j)," is: ", feasibleU(j))
        feasibleL(j) := getrange(XPRS_LOACT, CONSTRAINTS(j))
        writeln("RHS; Lower feasible limit of ", CONSTRAINT_NAMES(j)," is: ", feasibleL(j))
     writeln(" ")
  end-do

end-model
